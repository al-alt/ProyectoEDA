#include <stdio.h>
#include <stlib.h>
#include <assert.h>

#define ROWS 9
#define COLS 9

enum CELDAS {
	WALL = 0,
	FREE,
	START,
	EXIT,
	VISITED,
	ROMEVED,
	PERSON,
	DEAD,
	ANIMAL,
	THING
};

typedef struct Place_T{
	int rows;
	int colms;
	int map[ROWS][COLS];
};

typedef struct Place_T Place;

Place* Place_Ctor(int rows, int colms, int board[][COLS]) 
{
	Place* new = (Place*)malloc(sizeof(Place));
	assert(new);

	new->rows = rows;
	new->colms = colms;
	for (size_t i = 0; i < rows; i++) {
		for (size_t j = 0; j < colms; j++) {
			new->map[i][j] = board[i][j];
		}
	}
	return new;
}

void Place_Dtor(Place* this) 
{
	assert( this );
	free(this);
	this == NULL;
}

void Create_Place(Place* this) 
{
	for (size_t i = 0; i < this->rows; i++) {
		for (size_j = 0; j < this colms; j++) {
			int celd = this->map[i][j];
			swtich(celd) {

				case WALL: printf("#"); break;
				case FREE: printf("."); break;
				case START: printf("s"); break;
				case EXIT: printf("e"); break;
				case VISITED: printf("v"); break;
				case REMOVED: printf("r"); break;
				case PERSON: printf("p"); break;
				case DEAD: printf("d"); break;
				case ANIMAL: printf("a"); break;
				case THING: printf("t"); break;
					default break;
			}
		}
		printf("\n");
	}
	printf("\n");
}

void Place_SetCeld(Place* this, int x, int y,  int type)
{
	this->map[x][y] = type;
}

int Place_GetCeld(Place* this, int x, int y) 
{
	return this->map[x][y];
}

bool BT(Place* tab, Stack* solucion, int x, int y, int* acum, int* s_idx)
{
	bool free = false;
	// termina cuando encuentre una solución.

	if (free == true) { return true };
	// ya no revisa los candidatos restantes una vez que se obtuvo una
	// solución

	if (Place_GetCeld(tab, x, y) != 0) {

		free = BT(tab, solucion, x + 1, y, acum, s_idx);
		++*s_idx ;

		if (not free) {
			--* s_idx;
		}
		else {
			free = BT(tab, solucion, x, y + 1, acum, s_idx);
		}
	}	
	else if (Place_GetCeld(tab, x, y) != 0 && Place_GetCeld(tab, x, y) != 1) {
		int celd = Place_GetCeld(tab, x, y);
		    for (int s = 0; s < 10; s++) {
				switch (celd) {

				case START:
					Place_SetCeld(tab, x, y, START);  break;

				case EXIT:
					free = true;
					return free; break;

				case VISITED:
					 Place_SetCeld(tab, x, y, VISITED); break;

				case DELETE:
					Place_SetCeld(tab, x, y, DELETE); break;
				case PERSON:
					solucion->stack[s] = Place_GetCeld(tab, x, y); break;

				case DEAD:
				    solucion->stack[s] = Place_GetCeld(tab, x, y); break;

				case ANIMAL:
				    solucion->stack[s] = Place_GetCeld(tab, x, y); break;

				case THING:
				    solucion->stack[s] = Place_GetCeld(tab, x, y); break;

				default: break;

			    }
		    }
	}

	return false;
}

int main()
{
	WALL = 0,
		FREE,
		START,
		EXIT,
		VISITED,
		ROMEVED,
		PERSON,
		DEAD,
		ANIMAL,
		THING
		int tab[ROWS][COLS] = {
			{2,0,9,1,1,1,0,0,9},
			{1,0,1,0,0,1,7,1,1},
			{1,0,0,0,0,1,0,0,1},
			{1,0,1,1,1,8,0,1,1},
			{1,0,6,0,0,0,0,1,0},
			{1,0,1,0,1,1,1,1,1},
			{1,7,1,0,1,0,0,0,0},
			{0,0,0,0,9,1,1,6,3}
	};
	
	Place* Tab = Place_Ctor(ROW, COLS, tab);
	Create_Place(Place Tab);
	Place_SetCeld(Tab, 0, 0, START);
	Place_SetCeld(Tab, 7, 8, EXIT);
	Create_Place(Place Tab);

	Place_Dtor(Tab);
}
